package strips;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 
 * An Operator defines an operator for the problem being solved
 * by the linear planner. It is identified by its name and it can
 * have 0 or more parameters. They may, or may not, be instantiated.
 * Every operator has three lists of predicates: the preconditions,
 * the adds and the deletes.
 * 
 * Operators can be pushed into the stack of goals used by the
 * planning algorithm.
 * 
 * @author Javier Beltran, Jorge Rodriguez
 *
 */
public class Operator extends SingleStackable {
	
	private List<Predicate> preconditions;
	private List<Predicate> adds;
	private List<Predicate> deletes;

	/**
	 * Creates an Operator given its name, parameters, preconditions,
	 * adds and deletes.
	 */
	public Operator(String name, List<Predicate> preconditions, 
			List<Predicate> adds, List<Predicate> deletes, Parameter... params) {
		this.setName(name);
		this.setParams(Arrays.asList(params));
		
		this.preconditions = preconditions;
		this.adds = adds;
		this.deletes = deletes;
	}
	
	/**
	 * Creates an operation from an existing operation. That is, creates a copy
	 * of an existing operation with another reference.
	 */
	public Operator(Operator op) {
		/* Copies the name and parameters of the operator */
		setName(op.getName());
		setParams(new ArrayList<Parameter>());
		for (Parameter p : op.getParams()) {
			getParams().add(new Parameter(new String(p.getName()), new String(p.getValue())));
		}
		
		/* Copies the preconditions, adds and deletes tables of the operator */
		this.preconditions = copyTable(op.getPreconditions());
		this.adds = copyTable(op.getAdds());
		this.deletes = copyTable(op.getDeletes());
	}
	
	/**
	 * Auxiliar method for copying a table of the operator. Given a table as a list
	 * of predicates, it returns a copy of the same table.
	 */
	private List<Predicate> copyTable(List<Predicate> table) {
		/* Copies every predicate of the table */
		List<Predicate> copied = new ArrayList<>();
		for (Predicate pred : table) {
			/* Copies every parameter of the table with its old values */
			List<Parameter> ps = new ArrayList<Parameter>();
			for (Parameter p : pred.getParams()) {
				ps.add(new Parameter(new String(p.getName()), new String(p.getValue())));
			}
			Predicate newPred = new Predicate(pred.getName(), ps);

			copied.add(newPred);
		}
		return copied;
	}

	/**
	 * Instantiates the parameters of an operator using the predicate that
	 * is generated by the operation in the plan. Parameters should be properly
	 * tagged with distinctive names, so they can be translated to the operation.
	 */
	public Operator instantiate(Predicate pred) {
		Operator copiedOp = new Operator(this);
		/* Updates parameters of operator with the ones of predicate */
		copiedOp.setParams(updateList(pred.getParams(), copiedOp.getParams()));
		
		/* Updates parameters for the predicates in preconditions, adds and deletes */
		for (Predicate prec : copiedOp.getPreconditions()) {
			prec.setParams(updateList(pred.getParams(), prec.getParams()));
		}
		for (Predicate add : copiedOp.getAdds()) {
			add.setParams(updateList(pred.getParams(), add.getParams()));
		}
		for (Predicate del : copiedOp.getDeletes()) {
			del.setParams(updateList(pred.getParams(), del.getParams()));
		}
				
		return copiedOp;
	}
	
	/**
	 * Updates a list of parameters with the parameters of a predicate.
	 */
	private List<Parameter> updateList(List<Parameter> copy, List<Parameter> paste) {
		for (int i=0; i<paste.size(); i++) {
			for (int j=0; j<copy.size(); j++) {
				if (paste.get(i).getName().equals(copy.get(j).getName())) {
					paste.get(i).setValue(copy.get(j).getValue());
				}
			}
		}
		return paste;
	}
	
	/**
	 * Applies the operator to a state, that is, adds and deletes
	 * the predicates specified at the adds and deletes tables,
	 * respectively.
	 */
	public void apply(State state) {
		state.removePredicates(deletes);
		state.getPredicates().addAll(adds);
	}
	
	/* Getters and setters */

	public List<Predicate> getPreconditions() {
		return preconditions;
	}

	public void setPreconditions(List<Predicate> preconditions) {
		this.preconditions = preconditions;
	}

	public List<Predicate> getAdds() {
		return adds;
	}

	public void setAdds(List<Predicate> adds) {
		this.adds = adds;
	}

	public List<Predicate> getDeletes() {
		return deletes;
	}

	public void setDeletes(List<Predicate> deletes) {
		this.deletes = deletes;
	}
	
	public String toString() {
		String s = getName() + "(";
		for (int i=0; i<getParams().size(); i++) {
			s += getParams().get(i).toString();
			s += (i < getParams().size()-1) ? ", " : ")";
		}
		return s;
	}
	
}
